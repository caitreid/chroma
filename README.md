<img src="./images/opening.png" style="max-width:500px" /><br><br><br>


# CHROMA 

Table of Contents
* <a href="#Goals">Goals</a>
* <a href="#Technologies">Technologies</a>
* <a href="#Approach">Approach</a>
* <a href="#Commands">Commands</a>


## Goals

A User will be able to...
- Generate a unique puzzle 
- Initiate the puzzle's scramble with black dot "anchors" indicating which piece are permanently fixed on the board
- Click and drag a piece to be swapped with another square
- Play until the puzzle has been solved
- When the game is over, be alerted with how many moves they made 
- When the game is over, give the option to restart the game and play again with a new challenge
- Listen to meditative music while playing the game to give an introspective atmosphere

## Technologies

This application was built with: 
* HTML5
* Drag and Drop API
* SCSS
* Vanilla Javscript


Approach taken
Installation instructions
Unsolved problems, etc.

## Approach

### HTML + BEM 

The first part of the game I created was the game board. I began with a container surrounding each of the 25 dynamically colored squares.
I made a point to specifically use BEM Conventions when creating this complicated but essential architecture. It's what has drove the organization of subsequent style and script files.

```html
<div class="puzzle puzzle__container">
    <div class="puzzle__target" data-id="1">
        <div class="puzzle__piece" data-column="1" data-id="1" draggable="false"></div>
    </div>
    ...
</div>
``` 
<br>


Using HTML5's [Drag and Drop API](https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API), I needed to create not only the squares serving as puzzle pieces but also targets that serve as the container for which any a piece could be dropped into. 

As you can see, `puzzle__target` div surrounds each `puzzle__piece` div.

Next I gave each piece a data ID incrementing upwards by 1. This is important because when we check for the accuracy of the game, we look to see if the interior puzzle piece's ID matches the target/container.

Finally I will note that I were to re-factor and scale this project, I wouldn't start out with hard-coded HTML, but dynamically generate each board, each gradient, and each color problem set. However this is a good starting point before evolving to something more dynamic.



## Javascript
### Color.js


I was intentional about doing calculations for the board instead of hardcoding them because I wanted to leave open the possibility for changing the 4 colors with each game round, creating new challenges and color combinations. For V1, I've left it at four points, with the door open to create new levels.

First thing I did was define each of the four points

```javascript
let pointOne = [143, 201, 200] // Light Blue
let pointTwo = [243, 229, 118] // Yellow
let pointThree = [23, 54, 211] // Dark Blue
let pointFour = [230, 97, 125] // Red-Orange
```

These are the RGB values of each corner I wanted to create on the board. I've commented in the color each one corresponds to for reference.

Next I decided to create an object that stored the values of each generated color:

```javascript
let colorValues = {
   0: [pointOne, [], [], [], pointTwo],
   1: [[], [], [], [], []],
   2: [[], [], [], [], []],
   3: [[], [], [], [], []],
   4: [pointThree, [], [], [], pointFour]
}
 
```

The easiest part was calculating the outside square color values, because I already knew the initial four points.


However I created this data structure to keep track of the values that were generated by the gradient, that could then be used to find the intermediary values of the interior vertical gradients

### Point One to Point Two 

```javascript
let blocks = document.querySelectorAll('.puzzle__piece');


blocks.forEach((block, index) => {

   // pointOne to pointTwo
   if (index < 5 ) {

       percent = index / 4
  
       let varR = colorValues[0][0][0] + percent * (colorValues[0][4][0] - colorValues[0][0][0]);
       let varG = colorValues[0][0][1] + percent * (colorValues[0][4][1] - colorValues[0][0][1]);
       let varB = colorValues[0][0][2] + percent * (colorValues[0][4][2] - colorValues[0][0][2]);

       const generateColor =  `rgb( ${varR}, ${varG}, ${varB} )`
  
       colorValues[0][index][0] = varR
       colorValues[0][index][1] = varG
       colorValues[0][index][2] = varB

       block.style.backgroundColor = generateColor
   }

...

}
```



Looping over all of the blocks, I used the index to determine the position of the first, top row of the puzzle. 

I created four values `varR`, `varG` and varB` -- and then I set up my calculations to get the new value of the point based on its index position.

((( is that right?? )))

Then I made sure to add the calculated values into my `colorValues object`

```javascript
    colorValues[0][index][0] = varR
    colorValues[0][index][1] = varG
    colorValues[0][index][2] = varB
```

then I took the generated value and added it to the block at the particular index of my row.

```javascript
    const generateColor =  `rgb( ${varR}, ${varG}, ${varB} )`
 
    block.style.backgroundColor = generateColor
```

### Point 3 to Point 4

((( I think I want to add comments to color.js to really describe what every piece does...)))


### Point 1 to Point 3 (column 1)

To target each column, I made use of a data value I set on the blocks in the HTML. So to get the blocks from Point 1 to Point 3, I targeted everything designated as column 1.

`const col1 = document.querySelectorAll('[data-column="1"]')`

Then I looped over every block, calculated every new color based on the values in my colorValues object, and assigned it to the blocks

As you can see, the puzzle is starting to take shape.

At this point I no longer need to add the generated color values to the colorValues object. 




-

## Notes
- https://codepen.io/caitlinreid1/pen/ExpjeRY

## Commands

Handy Commands

`sass --watch scss/style.scss:css/style.css`





