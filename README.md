# CHROMA | A pattern-based puzzle.


## README REQs

Technologies used
Approach taken
Installation instructions
Unsolved problems, etc.


## User Stories

A User will be able to...
- Generate a unique puzzle with randomly generated colored squares using CSS Canvas
- Initiate a scrambled puzzle with black dot "anchors" indicating which squares are not to be shuffled
- Click and drag a piece to be swapped with another square
- Play until the puzzle has been solved
- When the game is over, be alerted with how many moves they made 
- When the game is over, give the option to restart the game and play again with a new challenge
- Listen to meditative music while playing the game (as per the original)



# Approach

## HTML
### BEM Convention


```
<div class="puzzle puzzle__container">
           <div class="puzzle__target" data-id="1">
               <div class="puzzle__piece" data-column="1" data-id="1" draggable="false"></div>
           </div>
           <div class="puzzle__target" data-id="2">
               <div class="puzzle__piece" data-column="2" data-id="2" draggable="false"></div>
           </div>
           <div class="puzzle__target" data-id="3">
               <div class="puzzle__piece" data-column="3" data-id="3" draggable="false"></div>
           </div>
```

The first part of the game I created was the game board. There's a `puzzle__container` surrounding each of the 25 dynamically colored squares.

Using HTML5's [Drag and Drop API](https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API), I needed to create not only the squares serving as puzzle pieces but also targets that serve as the container for which any a piece could be dropped into. As you can see, `puzzle__target` div surrounds each `puzzle__piece` div.

It's also important to note that I gave each piece a data ID incrementing upwards by 1. This is important because when we check for the accuracy of the game, we look to see if the interior puzzle piece's ID matches the target/container.

Additionally I added `data-column` to distinguish which pieces were in which column as I dynamically generated the gradient in `color.js`. I will say that if I were to re-factor and scale this project, I wouldn't start out with hard-coded HTML, but dynamically generate each board, each gradient, and each color problem set. However this is a good starting point before evolving to something more dynamic, and hopefully demonstrates well to an outside observer.


### Begin

The user is instructed to begin the game with the begin button. This initiated the board scramble and begins playing meditative music by Shivarasa.



## Javascript
### Color.js


I was intentional about doing calculations for the board instead of hardcoding them because I wanted to leave open the possibility for changing the 4 colors with each game round, creating new challenges and color combinations. For V1, I've left it at four points, with the door open to create new levels.

First thing I did was define each of the four points

```
let pointOne = [143, 201, 200] // Light Blue
let pointTwo = [243, 229, 118] // Yellow
let pointThree = [23, 54, 211] // Dark Blue
let pointFour = [230, 97, 125] // Red-Orange
```

These are the RGB values of each corner I wanted to create on the board. I've commented in the color each one corresponds to for reference.

Next I decided to create an object that stored the values of each generated color:

```
let colorValues = {
   0: [pointOne, [], [], [], pointTwo],
   1: [[], [], [], [], []],
   2: [[], [], [], [], []],
   3: [[], [], [], [], []],
   4: [pointThree, [], [], [], pointFour]
}
 
```

The easiest part was calculating the outside square color values, because I already knew the initial four points.


However I created this data structure to keep track of the values that were generated by the gradient, that could then be used to find the intermediary values of the interior vertical gradients

### Point One to Point Two 

```
let blocks = document.querySelectorAll('.puzzle__piece');


blocks.forEach((block, index) => {

   // pointOne to pointTwo
   if (index < 5 ) {

       percent = index / 4
  
       let varR = colorValues[0][0][0] + percent * (colorValues[0][4][0] - colorValues[0][0][0]);
       let varG = colorValues[0][0][1] + percent * (colorValues[0][4][1] - colorValues[0][0][1]);
       let varB = colorValues[0][0][2] + percent * (colorValues[0][4][2] - colorValues[0][0][2]);

       const generateColor =  `rgb( ${varR}, ${varG}, ${varB} )`
  
       colorValues[0][index][0] = varR
       colorValues[0][index][1] = varG
       colorValues[0][index][2] = varB

       // console.log('index of ', index, colorValues[0][index])

       //console.log(generateColor)
       block.style.backgroundColor = generateColor
   }

...

}
```



Looping over all of the blocks, I used the index to determine the position of the first, top row of the puzzle. 

I created four values `varR`, `varG` and varB` -- and then I set up my calculations to get the new value of the point based on its index position.

((( is that right?? )))

Then I made sure to add the calculated values into my `colorValues object`

```
colorValues[0][index][0] = varR
       colorValues[0][index][1] = varG
       colorValues[0][index][2] = varB
```

then I took the generated value and added it to the block at the particular index of my row.

```
       const generateColor =  `rgb( ${varR}, ${varG}, ${varB} )`
 
       block.style.backgroundColor = generateColor
```

### Point 3 to Point 4

((( I think I want to add comments to color.js to really describe what every piece does...)))


### Point 1 to Point 3 (column 1)

To target each column, I made use of a data value I set on the blocks in the HTML. So to get the blocks from Point 1 to Point 3, I targeted everything designated as column 1.

`const col1 = document.querySelectorAll('[data-column="1"]')`

Then I looped over every block, calculated every new color based on the values in my colorValues object, and assigned it to the blocks

As you can see, the puzzle is starting to take shape.

At this point I no longer need to add the generated color values to the colorValues object. 




-

## Notes
- https://codepen.io/caitlinreid1/pen/ExpjeRY

## Commands

`sass --watch scss/style.scss:css/style.css`





