<img src="./images/opening.png" style="max-width:500px" /><br><br><br>


# CHROMA 

Table of Contents
* <a href="#Goals">Goals</a>
* <a href="#Technologies">Technologies</a>
* <a href="#Approach">Approach</a>
* <a href="#Commands">Commands</a>
* <a href="#Roadmap">Roadmap</a>

## Goals

Chroma is a pattern-based puzzle game inspired by the iOS app, I Love Hue. My goal was to create an aesthetically pleasing web experience with a javascript-generated 4-pointed gradient, adding a meditative atmosphere to relax and entertain the user. In its current form, it is designed for desktop.

### User Stories

A User will be able to...
- Generate a unique puzzle 
- Initiate the puzzle's scramble with black dot "anchors" indicating which piece are permanently fixed on the board
- Click and drag a piece to be swapped with another square
- Play until the puzzle has been solved
- When the game is over, give the option to restart the game and play again
- Listen to meditative music while playing the game to give an introspective atmosphere

## Technologies

This web application was built with: 

* HTML5
* [Drag and Drop API](https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API)
* SCSS
* Vanilla Javscript


## Approach

In this README I will describe the puzzle's functionality as expressed in HTML, Javascript and SCSS. 

### HTML + BEM 

The first part of the game I created was the game board. I began with a container surrounding each of the 25 dynamically colored squares.
I made a point to specifically use BEM Conventions when creating this complicated but essential architecture. It's what has drove the organization of subsequent styling and script files. 



To begin, I used CSS Grid to arrange 25 divs inside a single container. The Drag and Drop API is designed such that for every **draggable element** there is a designated **drop target**. So Inside every square element, I added another div to serve as the actual puzzle "piece" that was swapped between locations.


<img src="./images/diagram_1.png" /><br><br>

Translated to code:

```html
<div class="puzzle puzzle__container">
    <div class="puzzle__target" data-id="1">
        <div class="puzzle__piece" data-column="1" data-id="1" draggable="false"></div>
    </div>
    ...
</div>
``` 
<br>



Using HTML5's [Drag and Drop API](https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API), I needed to create not only the squares serving as puzzle pieces but also targets that serve as the container for which any a piece could be dropped into. 

Next I gave each piece a `data-id` incrementing upwards by 1. This is important because when we check for the accuracy of the game, we look to see if the interior puzzle piece's ID matches the target. I also gave each piece a `data-column` to easily target the element in `color.js` where I dynamically add color to each piece on the board.

A final note on the HTML: I began this project with hardcoded HTML elements, however if I were to refactor this project, I would consider dynamically generating each element in javascript to easily update the number of pieces and orientation programmatically. However this is certainly a good starting point before developing something more dynamic.



## Javascript
### Color.js | Dynamically generate color values
My plan was to dynamically generate color values on the board instead of hardcoding them in SCSS. This is because I wanted to leave open the possibility for changing the pattern with each subsequent game round, creating new challenges and color combinations. 

First thing I did was define each of the four points

```javascript
let pointOne = [143, 201, 200] // Light Blue
let pointTwo = [243, 229, 118] // Yellow
let pointThree = [23, 54, 211] // Dark Blue
let pointFour = [230, 97, 125] // Red-Orange
```

These are the RGB values of each corner I wanted to create on the board. I've commented in the color each one corresponds to for reference.

Next I decided to create an object that stored the values of each generated color:

```javascript
let colorValues = {
   0: [pointOne, [], [], [], pointTwo],
   1: [[], [], [], [], []],
   2: [[], [], [], [], []],
   3: [[], [], [], [], []],
   4: [pointThree, [], [], [], pointFour]
}
 
```

The easiest part was calculating the outside square color values, because I already knew the initial four points.


However I created this data structure to keep track of the values that were generated by the gradient, that could then be used to find the intermediary values of the interior vertical gradients

### Point One to Point Two 

```javascript
let blocks = document.querySelectorAll('.puzzle__piece');


blocks.forEach((block, index) => {

   // pointOne to pointTwo
   if (index < 5 ) {

       percent = index / 4
  
       let varR = colorValues[0][0][0] + percent * (colorValues[0][4][0] - colorValues[0][0][0]);
       let varG = colorValues[0][0][1] + percent * (colorValues[0][4][1] - colorValues[0][0][1]);
       let varB = colorValues[0][0][2] + percent * (colorValues[0][4][2] - colorValues[0][0][2]);

       const generateColor =  `rgb( ${varR}, ${varG}, ${varB} )`
  
       colorValues[0][index][0] = varR
       colorValues[0][index][1] = varG
       colorValues[0][index][2] = varB

       block.style.backgroundColor = generateColor
   }

...

}
```



Looping over all of the blocks, I used the index to determine the position of the first, top row of the puzzle. 

I created four values `varR`, `varG` and varB` -- and then I set up my calculations to get the new value of the point based on its index position.

((( is that right?? )))

Then I made sure to add the calculated values into my `colorValues object`

```javascript
    colorValues[0][index][0] = varR
    colorValues[0][index][1] = varG
    colorValues[0][index][2] = varB
```

then I took the generated value and added it to the block at the particular index of my row.

```javascript
    const generateColor =  `rgb( ${varR}, ${varG}, ${varB} )`
 
    block.style.backgroundColor = generateColor
```

### Point 3 to Point 4

((( I think I want to add comments to color.js to really describe what every piece does...)))


### Point 1 to Point 3 (column 1)

To target each column, I made use of a data value I set on the blocks in the HTML. So to get the blocks from Point 1 to Point 3, I targeted everything designated as column 1.

`const col1 = document.querySelectorAll('[data-column="1"]')`

Then I looped over every block, calculated every new color based on the values in my colorValues object, and assigned it to the blocks

As you can see, the puzzle is starting to take shape.

At this point I no longer need to add the generated color values to the colorValues object. 



## Roadmap

After the successful launch of Version 1.0, there are still many features I look forward to developing. 

Chroma 2.0 will include:

* Mobile styles so Chroma can be played on any device, not just desktop
* Dedicated welcome screen with animated title
* Allow user to continue playing additional rounds with different generated patterns and challenges
* Improved Drag and Drop animations


## Commands

Comands used for development of this application

### Sass

`sass --watch scss/style.scss:css/style.css`

### ES Lint




